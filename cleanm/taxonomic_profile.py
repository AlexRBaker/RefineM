###############################################################################
#                                                                             #
#    This program is free software: you can redistribute it and/or modify     #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License, or        #
#    (at your option) any later version.                                      #
#                                                                             #
#    This program is distributed in the hope that it will be useful,          #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#                                                                             #
#    You should have received a copy of the GNU General Public License        #
#    along with this program. If not, see <http://www.gnu.org/licenses/>.     #
#                                                                             #
###############################################################################

__author__ = 'Donovan Parks'
__copyright__ = 'Copyright 2014'
__credits__ = ['Donovan Parks']
__license__ = 'GPL3'
__maintainer__ = 'Donovan Parks'
__email__ = 'donovan.parks@gmail.com'

import os
import sys
import ntpath
import logging
import operator
from collections import defaultdict, namedtuple

import time

from biolib.seq_io import SeqIO
from biolib.seq_tk import SeqToolkit
from biolib.common import make_sure_path_exists, alphanumeric_sort
from biolib.external.diamond import Diamond
from biolib.plots.pie_chart import PieChart

from numpy import mean


"""
To Do:
 1. Need to get GC and coverage (and possibily tetras) into the mix
 7. svg pie charts for each genome at each rank [top X, unclassified, other]
"""


class TaxonomicProfile(object):
    """Create taxonomic profiles for a set of genomes.

    Taxonomic profiles are generated by fragmenting each sequence
    in a genome into fixed sizes windows with a given step size.
    Each window is then classified through homolog search against a
    database of reference genomes. Currently, homology search with blastx
    and diamond are supported. Each contig is assigned using a majority
    vote at each taxonomic rank. The taxonomic profile of a genome
    is given as the total number of base pairs assigned to each taxa.
    """

    RANK_PREFIXES = ['d__', 'p__', 'c__', 'o__', 'f__', 'g__', 's__']
    RANKS = ['domain', 'phylum', 'class', 'order', 'family', 'genus', 'species']

    def __init__(self, cpus, output_dir):
        """Initialization.

        Parameters
        ----------
        cpus : int
            Number of cpus to use.
        output_dir : str
            Directory to store results.
        """
        self.logger = logging.getLogger()

        self.cpus = cpus
        self.output_dir = output_dir

        # profile for each genome
        self.profiles = {}

    def fragment_genomes(self, genome_files, window_size, step_size, fragment_file):
        """Fragment genome sequences into fragments of a fixed size.

        Parameters
        ----------
        genome_files : list of str
            Fasta files of genomes to process.
        window_size : int
            Size of each fragment.
        step_size : int
            Number of bases to move after each window.
        fragment_file : str
            Output file to store all fragments.

        Returns
        -------
        dict : d[contig_id] -> genome_id
            Map contig ids to their source genome.
        """

        seq_io = SeqIO()
        seq_tk = SeqToolkit()

        fout = open(fragment_file, 'w')

        contig_id_to_genome_id = {}
        for processed_files, f in enumerate(genome_files):
            status = '    Finished processing %d of %d (%.2f%%) genomes.' % (processed_files + 1,
                                                                             len(genome_files),
                                                                             float(processed_files + 1) * 100 / len(genome_files))
            sys.stdout.write('%s\r' % status)
            sys.stdout.flush()

            genome_id = ntpath.basename(f)
            genome_id = os.path.splitext(genome_id)[0]
            total_fragments = 0

            self.profiles[genome_id] = Profile(genome_id)
            for seq_id, seq in seq_io.read_seq(f):
                fragments = seq_tk.fragment(seq, window_size, step_size)
                for i, frag in enumerate(fragments):
                    fout.write('>' + seq_id + '~' + str(i) + '\n')
                    fout.write(frag + '\n')

                    contig_id_to_genome_id[seq_id] = genome_id
                    total_fragments += 1

                self.profiles[genome_id].fragments_from_seq[seq_id] = len(fragments)
                self.profiles[genome_id].seq_len[seq_id] = len(seq)

            self.profiles[genome_id].total_fragments = total_fragments

        fout.close()
        sys.stdout.write('\n')

        return contig_id_to_genome_id

    def read_taxonomy(self, taxonomy_file):
        """Read taxonomic assignment of each genome

        Parameters
        ----------
        taxonomy_file : str
            File containing taxonomic assignment of each reference genome.
        """

        taxonomy = {}
        for line in open(taxonomy_file):
            line_split = line.split('\t')
            taxonomy[line_split[0]] = [x.strip() for x in line_split[1].split(';')]

        return taxonomy

    def taxonomic_profiles(self, table, taxonomy, contig_id_to_genome_id):
        """Create taxonomic profiles.

        Parameters
        ----------
        table : str
            Table containing hits to genomic fragments.
        taxonomy : dict[ref_genome_id] -> [domain, phylum, ..., species]
            Taxonomic assignment of each reference genome.
        contig_id_to_genome_id : dict[contig_id] -> genome_id
            Map contig ids to their source genome.
        """

        for hit in Diamond().read_blast_table(table):
            contig_id = hit.query_id[0:hit.query_id.rfind('~')]
            genome_id = contig_id_to_genome_id[contig_id]
            ref_genome_id = hit.subject_id[0:hit.subject_id.rfind('~')]

            self.profiles[genome_id].add_hit(contig_id,
                                             taxonomy[ref_genome_id],
                                             hit.evalue,
                                             hit.perc_identity,
                                             hit.aln_length)

    def write_genome_summary(self, output_file):
        """Summarize classification of each genome.

        Parameters
        ----------
        output_file : str
            Output file.
        """

        fout = open(output_file, 'w')
        fout.write('Genome id\tLength (bp)\t# sequences\t')
        for rank in TaxonomicProfile.RANKS:
            fout.write('\t' + rank + ': taxa')
            fout.write('\t' + rank + ': percent of bps')
            fout.write('\t' + rank + ': percent of sequences')
            fout.write('\t' + rank + ': avg. evalue')
            fout.write('\t' + rank + ': avg. perc identity')
            fout.write('\t' + rank + ': avg. align length')
        fout.write('\n')

        sorted_genome_ids = alphanumeric_sort(self.profiles.keys())
        for genome_id in sorted_genome_ids:
            self.profiles[genome_id].write_genome_summary(fout)

        fout.close()

    def run(self, genome_files, db_file, taxonomy_file, evalue, per_identity, window_size, step_size):
        """Create taxonomic profiles for a set of genomes.

        Parameters
        ----------
        genome_files : list of str
            Fasta files of genomes to process.
        evalue : float
            E-value threshold used by blast.
        per_identity: float
            Percent identity threshold used by blast.
        window_size : int
            Size of each fragment.
        step_size : int
            Number of bases to move after each window.
        """

        # fragment each genome into fixed sizes windows
        self.logger.info('  Fragmenting sequences in each bin:')
        fragment_file = os.path.join(self.output_dir, 'fragments.fna')
        contig_id_to_genome_id = self.fragment_genomes(genome_files, window_size, step_size, fragment_file)

        # run diamond
        self.logger.info('')
        diamond_out = os.path.join(self.output_dir, 'diamond.results.tsv')
        diamond = Diamond(self.cpus)
        diamond.homology_criteria(evalue, per_identity)
        # diamond.blastx(fragment_file, db_file, diamond_out)

        self.logger.info('')
        self.logger.info('  Reading taxonomic assignment of each reference genome.')
        taxonomy = self.read_taxonomy(taxonomy_file)

        self.logger.info('')
        self.logger.info('  Creating taxonomic profile for each genome.')
        s = time.time()
        self.taxonomic_profiles(diamond_out, taxonomy, contig_id_to_genome_id)
        e = time.time()
        print '  Time: %.1f' % (e - s)

        self.logger.info('')
        self.logger.info('  Writing taxonomic profile for each genome.')
        s = time.time()

        report_dir = os.path.join(self.output_dir, 'reports')
        make_sure_path_exists(report_dir)
        for genome_id, profile in self.profiles.iteritems():
            seq_summary_out = os.path.join(report_dir, genome_id + '.sequences.tsv')
            profile.write_seq_summary(seq_summary_out)

            genome_profile_out = os.path.join(report_dir, genome_id + '.profile.tsv')
            profile.write_genome_profile(genome_profile_out)

        genome_summary_out = os.path.join(self.output_dir, 'genome_summary.tsv')
        self.write_genome_summary(genome_summary_out)

        e = time.time()

        print '  Time: %.1f' % (e - s)

        self.profiles['bin_9'].print_summary(0)
        print ''
        self.profiles['bin_9'].print_summary(1)
        print ''
        self.profiles['bin_9'].print_summary(2)

        pie_chart = PieChart()
        pie_chart.plot()
        pie_chart.save_plot('test.png')


class Profile(object):
    """Profile of hits to reference genomes."""

    def __init__(self, genome_id):
        """Initialization."""

        self.genome_id = genome_id
        self.unclassified = 'unclassified'

        self.TaxaInfo = namedtuple('TaxaInfo', """evalue
                                                perc_identity
                                                aln_length
                                                num_seqs
                                                num_basepairs""")

        # tack hits at each rank: dict[contig_id][rank][taxa] -> [HitInfo, ...]
        self.HitInfo = namedtuple('HitInfo', """evalue
                                                perc_identity
                                                aln_length""")
        self.hits = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))

        # total fragments from genome
        self.total_fragments = 0

        # length of contigs
        self.seq_len = {}

        # number of fragments from each sequence
        self.fragments_from_seq = {}

    def add_hit(self, seq_id, taxonomy, evalue, perc_identity, aln_length):
        """Add hit to profile.

        Parameters
        ----------
        seq_id : str
            Unique identifier of sequence from which hit arose.
        taxonomy : list
            List indication taxa at each taxonomic rank.
        evalue : float
            E-value of hit.
        per_identity: float
            Percent identity of hit.
        aln_length: int
            Alignment length of hit.
        """

        d = self.hits[seq_id]
        for i, taxa in enumerate(taxonomy):
            d[i][taxa].append(self.HitInfo(evalue, perc_identity, aln_length))

    def classify_seqs(self, rank):
        """Classify sequences at a given taxonomic rank.

        Sequences are classified using a majority vote
        over all fragments originating from the sequence
        with a valid hit. If less than 20% of fragments have
        a valid hit, the sequence is considered unclassified.

        Parameters
        ----------
        rank : int
            Desired rank.

        Returns
        -------
        dict : d[seq_id] -> [taxa, HitInfo]
            Classification of each sequence along with summary statistics
            of hits to the specified taxa.
        """

        # classify each sequence using a majority vote
        seq_assignments = defaultdict(lambda: defaultdict(str))

        for seq_id, rank_hits in self.hits.iteritems():
            taxa = max(rank_hits[rank], key=lambda x: len(rank_hits[rank][x]))
            count = len(rank_hits[rank][taxa])

            if count >= 0.2 * self.fragments_from_seq[seq_id]:
                seq_assignments[seq_id] = [taxa, rank_hits[rank][taxa]]
            else:
                seq_assignments[seq_id] = [self.unclassified, None]

        # identify sequences with no hits
        for seq_id in self.seq_len:
            if seq_id not in seq_assignments:
                seq_assignments[seq_id] = [self.unclassified, None]

        return seq_assignments

    def profile_at_rank(self, rank):
        """Return profile at a given taxonomic rank.

        Relative abundance is derived from the number
        of base pairs assigned to a given taxa.

        Parameters
        ----------
        rank : int
            Desired rank.

        Returns
        -------
        dict : d[taxa] -> percentage
            Relative abundance of taxa at a given rank.
        dict : d[taxa] -> TaxaInfo
           Statistics for each taxa.
        """

        seq_assignments = self.classify_seqs(rank)

        total_bps = sum(self.seq_len.values())

        profile = defaultdict(float)
        hit_stats = defaultdict(list)
        num_seqs = defaultdict(int)
        num_basepairs = defaultdict(int)
        for seq_id, data in seq_assignments.iteritems():
            taxa, hit_info = data
            profile[taxa] += float(self.seq_len[seq_id]) / total_bps
            num_seqs[taxa] += 1
            num_basepairs[taxa] += self.seq_len[seq_id]

            if taxa != self.unclassified:
                hit_stats[taxa].extend(hit_info)

        # calculate averages of hit statistics
        stats = {}
        for taxa, hit_info in hit_stats.iteritems():
            avg_evalue = mean([x.evalue for x in hit_info])
            avg_perc_identity = mean([x.perc_identity for x in hit_info])
            avg_aln_length = mean([x.aln_length for x in hit_info])

            stats[taxa] = self.TaxaInfo(avg_evalue,
                                        avg_perc_identity,
                                        avg_aln_length,
                                        num_seqs[taxa],
                                        num_basepairs[taxa])

        stats[self.unclassified] = self.TaxaInfo(None,
                                                 None,
                                                 None,
                                                 num_seqs[self.unclassified],
                                                 num_basepairs[self.unclassified])

        return profile, stats

    def print_summary(self, rank):
        """Print profile summary at specified rank.

        Parameters
        ----------
        rank : int
            Desired rank.
        """

        profile, stats = self.profile_at_rank(rank)

        for taxa, percent in profile.iteritems():
            if taxa != self.unclassified:
                print '%s\t%.2f\t%d\t%d\t%.1g\t%.1f\t%.1f' % (taxa,
                                                      percent,
                                                      stats[taxa].num_seqs,
                                                      stats[taxa].num_basepairs,
                                                      stats[taxa].evalue,
                                                      stats[taxa].perc_identity,
                                                      stats[taxa].aln_length)
            else:
                print '%s\t%.2f\t%d\t%d' % (taxa,
                                            percent,
                                            stats[taxa].num_seqs,
                                            stats[taxa].num_basepairs)

    def write_genome_summary(self, fout):
        """Write most abundant taxa at each rank.

        Parameters
        ----------
        fout : output stream
            Output stream.
        """

        fout.write('%s\t%d\t%d' % (self.genome_id, sum(self.seq_len.values()), len(self.seq_len)))
        for r in xrange(0, len(TaxonomicProfile.RANKS)):
            profile, stats = self.profile_at_rank(r)

            taxa, percent = max(profile.iteritems(), key=operator.itemgetter(1))

            total_seq = sum([stats[t].num_seqs for t in stats])

            if taxa != self.unclassified:
                fout.write('\t%s\t%.2f\t%.2f\t%.1g\t%.1f\t%.1f' % (taxa,
                                                              percent * 100,
                                                              stats[taxa].num_seqs * 100.0 / total_seq,
                                                              stats[taxa].evalue,
                                                              stats[taxa].perc_identity,
                                                              stats[taxa].aln_length))
            else:
                fout.write('\t%s\t%.2f\t%.2f\t%s\t%s\t%s' % (taxa,
                                                          percent * 100,
                                                          stats[taxa].num_seqs * 100.0 / total_seq,
                                                          'na',
                                                          'na',
                                                          'na'))

        fout.write('\n')

    def write_genome_profile(self, output_file):
        """Write complete profile.

        Parameters
        ----------
        output_file : str
            Output file.
        """

        fout = open(output_file, 'w')
        for rank in TaxonomicProfile.RANKS:
            if rank != TaxonomicProfile.RANKS[0]:
                fout.write('\t')

            fout.write(rank + ': taxa')
            fout.write('\t' + rank + ': percent of bps')
            fout.write('\t' + rank + ': percent of sequences')
            fout.write('\t' + rank + ': avg. evalue')
            fout.write('\t' + rank + ': avg. perc identity')
            fout.write('\t' + rank + ': avg. align length')
        fout.write('\n')

        # sort profiles in descending order of abundance
        sorted_profiles = {}
        stats_dict = {}
        max_taxa = 0
        for r in xrange(0, len(TaxonomicProfile.RANKS)):
            profile, stats = self.profile_at_rank(r)

            sorted_profile = sorted(profile.items(), key=operator.itemgetter(1))
            sorted_profile.reverse()

            sorted_profiles[r] = sorted_profile
            stats_dict[r] = stats

            if len(sorted_profiles) > max_taxa:
                max_taxa = len(sorted_profiles)

        # write out table
        for i in xrange(0, max_taxa):
            for r in xrange(0, len(TaxonomicProfile.RANKS)):
                if r != 0:
                    fout.write('\t')

                if len(sorted_profiles[r]) > i:
                    stats = stats_dict[r]
                    total_seq = sum([stats[t].num_seqs for t in stats])

                    taxa, percent = sorted_profiles[r][i]

                    if taxa != self.unclassified:
                        fout.write('%s\t%.2f\t%.2f\t%.1g\t%.1f\t%.1f' % (taxa,
                                                                      percent * 100,
                                                                      stats[taxa].num_seqs * 100.0 / total_seq,
                                                                      stats[taxa].evalue,
                                                                      stats[taxa].perc_identity,
                                                                      stats[taxa].aln_length))
                    else:
                        fout.write('%s\t%.2f\t%.2f\t%s\t%s\t%s' % (taxa,
                                                                  percent * 100,
                                                                  stats[taxa].num_seqs * 100.0 / total_seq,
                                                                  'na',
                                                                  'na',
                                                                  'na'))
                else:
                    fout.write('\t\t\t\t\t')

            fout.write('\n')

    def write_seq_summary(self, output_file):
        """Summarize classification of each sequence.

        Parameters
        ----------
        output_file : str
            Output file.
        """

        seq_assignments = {}
        for r in xrange(0, len(TaxonomicProfile.RANKS)):
            seq_assignments[r] = self.classify_seqs(r)

        fout = open(output_file, 'w')
        fout.write('Sequence id\tLength (bp)\t# fragments\t')
        for rank in TaxonomicProfile.RANKS:
            fout.write('\t' + rank + ': taxa')
            fout.write('\t' + rank + ': hits (%)')
            fout.write('\t' + rank + ': avg. evalue')
            fout.write('\t' + rank + ': avg. perc identity')
            fout.write('\t' + rank + ': avg. align length')
        fout.write('\n')

        for seq_id, data in seq_assignments[0].iteritems():
            taxa, _hit_info = data
            fout.write('%s\t%d\t%d' % (seq_id,
                                       self.seq_len[seq_id],
                                       self.fragments_from_seq[seq_id]))

            for r in xrange(0, len(TaxonomicProfile.RANKS)):
                taxa, hit_info = seq_assignments[r][seq_id]

                if taxa != self.unclassified:
                    avg_evalue = mean([x.evalue for x in hit_info])
                    avg_perc_identity = mean([x.perc_identity for x in hit_info])
                    avg_aln_length = mean([x.aln_length for x in hit_info])

                    hit_str = '%d (%.1f%%)' % (len(hit_info),
                                               len(hit_info) * 100.0 / self.fragments_from_seq[seq_id])
                    fout.write('\t%s\t%s\t%.1g\t%.1f\t%.1f' % (taxa,
                                                               hit_str,
                                                               avg_evalue,
                                                               avg_perc_identity,
                                                               avg_aln_length))
                else:
                    fout.write('\t%s\t%s\t%s\t%s\t%s' % (taxa,
                                                           'na',
                                                           'na',
                                                           'na',
                                                           'na'))
            fout.write('\n')
